# -*- coding: utf-8 -*-
"""Time Series forecasting GOCE BAT CUR

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TENbBXntiF1V-47b7DY1UTfm6SQ03-YL

Dados GOGE
"""

import pandas as pd
import matplotlib.pyplot as plt

from google.colab import drive
drive.mount('/content/drive')
#Lista de todos os 327 paramentros coletados pelo GOCE
metadata = "/content/drive/MyDrive/dados/metadata.csv"
#dados de corrente nominal de carga
PHT10040_raw="/content/drive/MyDrive/dados/PHT10040/PHT10040_raw.parquet"
PHT10040_10min="/content/drive/MyDrive/dados/PHT10040/PHT10040_stats_10min.parquet"
PHT10040_6h="/content/drive/MyDrive/dados/PHT10040/PHT10040_stats_6h.parquet"

"""# Vizualizando os dados

"""

meta_data = pd.read_csv(metadata)
meta_data

meta_data.loc[161:164]#dados de carga e descarga de corrente
meta_data.loc[300:301]#dados de tensão

df_PHT10040_raw = pd.read_parquet(PHT10040_raw)
df_PHT10040_raw

df_PHT10040_10min = pd.read_parquet(PHT10040_10min)
#df_PHT10040_10min

df_PHT10040_6h = pd.read_parquet(PHT10040_6h)
df_PHT10040_6h

raw = df_PHT10040_raw
dezmin = df_PHT10040_10min
seish = df_PHT10040_6h

fig, ax = plt.subplots(figsize=(15, 5))
raw.plot(ax=ax, label='Bruto')
dezmin['value_mean'].plot(ax=ax, label='10-min ')
seish['value_mean'].plot(ax=ax, label='6-h ')
plt.ylim(0, 35)
plt.title('Curvas de carga e descarga durante todo o periodo')
ax.set_xlabel('Tempo (Horas)')
ax.set_ylabel('Corrente (A)')
ax.legend()
plt.show()

raw = df_PHT10040_raw.loc[(df_PHT10040_raw.index >= '2011-10-21 00:00:00') & (df_PHT10040_raw.index <= '2011-10-22 00:00:00')]
dezmin = df_PHT10040_10min.loc[(df_PHT10040_10min.index >= '2011-10-21 00:00:00') & (df_PHT10040_10min.index <= '2011-10-22 00:00:00')]
seish = df_PHT10040_6h.loc[(df_PHT10040_6h.index >= '2011-10-21 00:00:00') & (df_PHT10040_6h.index <= '2011-10-22 00:00:00')]

fig, ax = plt.subplots(figsize=(15, 5))
raw.plot(ax=ax, label='Raw Data', title='Curvas de carga e descarga durante um dia')
dezmin['value_mean'].plot(ax=ax, label='10-min ')
seish['value_mean'].plot(ax=ax, label='6-h ')
ax.set_xlabel('Tempo (Horas)')
ax.set_ylabel('Corrente (A)')
ax.legend()
plt.show()

"""# Tratamento dos dados"""

#df_PHT10040_raw.isna()
#df_PHT10040_raw.isna().sum()

df_PHT10040_10min.isna()
df_PHT10040_10min.isna().sum()

#df_PHT10040_6h.isna()
#df_PHT10040_6h.isna().sum()

df_PHT10040_10min['hour'] = df_PHT10040_10min.index.hour
df_PHT10040_10min['minute'] = df_PHT10040_10min.index.minute
means_by_time = df_PHT10040_10min.groupby(['hour', 'minute']).transform('mean')
df_PHT10040_10min = df_PHT10040_10min.fillna(means_by_time)
df_PHT10040_10min = df_PHT10040_10min.drop(columns=['hour', 'minute'])

df_PHT10040_6h['hour'] = df_PHT10040_6h.index.hour
means_by_time = df_PHT10040_6h.groupby(['hour']).transform('mean')
df_PHT10040_6h = df_PHT10040_6h.fillna(means_by_time)
df_PHT10040_6h = df_PHT10040_6h.drop(columns=['hour'])

raw = df_PHT10040_raw
dezmin = df_PHT10040_10min
seish = df_PHT10040_6h

fig, ax = plt.subplots(figsize=(15, 5))
raw.plot(ax=ax, label='Bruto')
dezmin['value_mean'].plot(ax=ax, label='10-min ')
seish['value_mean'].plot(ax=ax, label='6-h ')
plt.ylim(0, 35)
plt.title('Curvas de carga e descarga durante todo o periodo')
ax.set_xlabel('Tempo (Horas)')
ax.set_ylabel('Corrente (A)')
ax.legend()
plt.show()

"""# Criando Parâmetros"""

df_PHT10040_10min=df_PHT10040_10min['value_mean']
df_PHT10040_6h=df_PHT10040_6h['value_mean']

import numpy as np
from sklearn.metrics import mean_squared_error, mean_absolute_error

def criando_parametros(df_data, lags=[1, 2, 6, 12, 24], target_column='value_mean'):
    df_data = df_data.copy()


    if isinstance(df_data, pd.Series):
        df_data = df_data.to_frame(name=target_column)

    df_data.index = pd.to_datetime(df_data.index)


    df_data['hour'] = df_data.index.hour
    df_data['dayofweek'] = df_data.index.dayofweek
    df_data['quarter'] = df_data.index.quarter
    df_data['month'] = df_data.index.month
    df_data['year'] = df_data.index.year
    df_data['dayofyear'] = df_data.index.dayofyear
    df_data['dayofmonth'] = df_data.index.day
    df_data['weekofyear'] = df_data.index.isocalendar().week.astype(int)

    for lag in lags:
        df_data[f"lag_{lag}"] = df_data[target_column].shift(lag)

    return df_data

df_PHT10040_raw = criando_parametros(df_PHT10040_raw, target_column='value')
df_PHT10040_10min = criando_parametros(df_PHT10040_10min, target_column='value_mean')
df_PHT10040_6h = criando_parametros(df_PHT10040_6h, target_column='value_mean')

import seaborn as sns
fig, ax = plt.subplots(figsize=(10, 8))
sns.boxplot(data=df_PHT10040_raw, x='month', y='value')
ax.set_title('Distribuição de corrente por mês')
ax.set_xlabel('Mês')
ax.set_ylabel('Corrente (A)')
plt.show()

"""# Validação cruzada de series temporais"""

from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_squared_error, mean_absolute_error
import warnings
warnings.filterwarnings('ignore')

FEATURES = [
    'hour', 'month', 'year', 'dayofyear', 'dayofmonth','dayofweek','quarter','weekofyear',
    'lag_1', 'lag_2', 'lag_6', 'lag_12', 'lag_24'
]
TARGET = "value"
TARGET_2="value_mean"


X_1=df_PHT10040_raw[FEATURES]
X_2=df_PHT10040_10min[FEATURES]
X_3=df_PHT10040_6h[FEATURES]

Y_1 = df_PHT10040_raw[TARGET]
Y_2 = df_PHT10040_10min[TARGET_2]
Y_3 = df_PHT10040_6h[TARGET_2]

import matplotlib.pyplot as plt
from sklearn.model_selection import TimeSeriesSplit

def executar_timeseries_cv(X, y, n_splits=5):
    tscv = TimeSeriesSplit(n_splits=n_splits)
    resultados = []
    split_num = 1

    for train_idx, val_idx in tscv.split(X):

        resultados.append({
            "split": split_num,
            "train_idx": train_idx,
            "val_idx": val_idx,
            "X_train": X.iloc[train_idx],
            "X_val": X.iloc[val_idx],
            "y_train": y.iloc[train_idx],
            "y_val": y.iloc[val_idx],
        })

        split_num += 1

    return resultados

def plotar_split(resultados_split, y, nome_dataset):
    split = resultados_split["split"]
    train_idx = resultados_split["train_idx"]
    val_idx = resultados_split["val_idx"]

    plt.figure(figsize=(14,4))
    plt.scatter(y.index[train_idx], y.iloc[train_idx], s=8, label="Treino")
    plt.scatter(y.index[val_idx],   y.iloc[val_idx],  s=12, label="Validação", color='orange')

    plt.title(f"{nome_dataset} – Split {split}")
    plt.xlabel("Tempo (datas)")
    plt.ylabel("Valor")
    plt.grid(True)
    plt.legend()
    plt.show()

def rodar_e_plotar_cv(X, y, nome_dataset, n_splits=5):
    resultados = executar_timeseries_cv(X, y, n_splits)

    print(f"\n\n=== TimeSeriesSplit em {nome_dataset} ===")
    for split_info in resultados:
        print(f"Plotando Split {split_info['split']}...")
        plotar_split(split_info, y, nome_dataset)

    return resultados

splits_raw  = executar_timeseries_cv(X_1, Y_1,5)
splits_10m  = rodar_e_plotar_cv(X_2, Y_2, "10 MIN")
splits_6h   = rodar_e_plotar_cv(X_3, Y_3, "6 HORAS")

"""
# Treinamento do modelo"""

import xgboost as xgb
import numpy as np

def treinar_xgboost_em_splits(X, y, resultados_cv, nome_dataset):
    metricas = []

    print(f"\n {nome_dataset}")

    for split_info in resultados_cv:
        split = split_info["split"]
        X_train = split_info["X_train"]
        X_val   = split_info["X_val"]
        y_train = split_info["y_train"]
        y_val   = split_info["y_val"]

        model = xgb.XGBRegressor(
            n_estimators=300,
            learning_rate=0.05,
            early_stopping_rounds=50,
            max_depth=5,
            subsample=0.8,
            colsample_bytree=0.8,
            objective="reg:squarederror"
        )

        model.fit(X_train, y_train, eval_set=[(X_val, y_val)], verbose=False)

        # Predição no split
        y_pred = model.predict(X_val)

        # Métricas
        mae = mean_absolute_error(y_val, y_pred)
        rmse = np.sqrt(mean_squared_error(y_val, y_pred))

        metricas.append({
            "split": split,
            "MAE": mae,
            "RMSE": rmse,
            "modelo": model,
            "y_pred": y_pred,
            "y_val": y_val,
            "X_val": X_val
        })

        print(f"Split {split}")
        print(f"MAE  = {mae:.4f}")
        print(f"RMSE = {rmse:.4f}")

    return metricas

#metricas_raw  = treinar_xgboost_em_splits(X_1, Y_1, splits_raw, "RAW")
metricas_10m  = treinar_xgboost_em_splits(X_2, Y_2, splits_10m, "10 MIN")
metricas_6h   = treinar_xgboost_em_splits(X_3, Y_3, splits_6h, "6 HORAS")

"""# Validação do modelo"""

def plot_pred_vs_real(split_info, y, nome_dataset):
    split = split_info["split"]
    y_val = split_info["y_val"]
    y_pred = split_info["y_pred"]

    plt.figure(figsize=(14,4))
    plt.plot(y_val.index, y_val.values, label="Real", linewidth=2)
    plt.plot(y_val.index, y_pred, label="Previsão", linewidth=2)

    plt.title(f"Previsão vs Real – {nome_dataset} (Split {split})")
    plt.xlabel("Tempo")
    plt.ylabel("Valor")
    plt.grid(True)
    plt.legend()
    plt.show()

def plot_feature_importance(modelo, features, nome_dataset):
    importance = modelo.feature_importances_

    plt.figure(figsize=(8,5))
    plt.barh(features, importance)
    plt.title(f"Importância das Features – {nome_dataset}")
    plt.xlabel("Importância")
    plt.grid(True)
    plt.show()

plot_pred_vs_real(metricas_10m[3], Y_1, "RAW")

ultimo_modelo = metricas_10m[-1]["modelo"]
plot_feature_importance(ultimo_modelo, X_1.columns, "10min")

"""#Predições"""

def montar_predicoes_no_dataframe(df, metricas, coluna_valor="value_mean"):
    """
    Insere todas as previsões dos splits (já treinados) dentro do DataFrame original.
    Cria uma coluna df['prediction'] com NaN para treinos e valores previstos para validação.
    """
    df = df.copy()

    # cria coluna prediction se não existir
    df["prediction"] = np.nan

    for m in metricas:
        y_val = m["y_val"]
        y_pred = m["y_pred"]

        # garante alinhamento por índice datetime
        df.loc[y_val.index, "prediction"] = y_pred

    return df
df_pred_10min = montar_predicoes_no_dataframe(df_PHT10040_10min, metricas_10m)

#ax = df_pred_raw["value"].plot(figsize=(15,5), label="Real")
#df_pred_raw["prediction"].plot(ax=ax, style=".", label="Predição")

#plt.legend()
#plt.title("Valores Reais vs Predição – RAW")
#plt.show()

df_pred_10m = montar_predicoes_no_dataframe(df_PHT10040_10min, metricas_10m, coluna_valor="value_mean")
df_pred_6h = montar_predicoes_no_dataframe(df_PHT10040_6h, metricas_6h, coluna_valor="value_mean")

ax = df_pred_10m["value_mean"].plot(figsize=(15,5), label="Real")
df_pred_10m["prediction"].plot(ax=ax, style=".", label="Predição")

plt.legend()
plt.title("Valores Reais vs Predição – 10min")
plt.show()

ax = df_pred_6h["value_mean"].plot(figsize=(15,5), label="Real")
df_pred_6h["prediction"].plot(ax=ax, style=".", label="Predição")

plt.legend()
plt.title("Valores Reais vs Predição – 6h")
plt.show()